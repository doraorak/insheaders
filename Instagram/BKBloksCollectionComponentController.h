//
//   Generated by https://github.com/blacktop/ipsw (Version: 3.1.468, BuildCommit: a1243d3a18f9b0e29af55a12ad74ccd2cd1f0abc)
//
//    - LC_BUILD_VERSION:  Platform: iOS, MinOS: 15.0, SDK: 17.4, Tool: ld (16.0)
//    - LC_SOURCE_VERSION: 
//
#ifndef BKBloksCollectionComponentController_h
#define BKBloksCollectionComponentController_h
@import Foundation;

#include "BKBloksComponentController.h"
#include "BKBloksCollectionScrollIndicatorView.h"
#include "UICollectionViewDataSource-Protocol.h"
#include "UICollectionViewDelegate-Protocol.h"
#include "UICollectionViewDelegateFlowLayout-Protocol.h"
#include "UIScrollViewDelegate-Protocol.h"

@class BKLispyExpression, BKModel, NSArray, NSIndexPath, NSString, UICollectionView;
@protocol BKBloksCollectionComponentControllerDelegate, BKBloksCollectionLayoutManager, {CKCocoaCollectionAdapter<BKBloksCollectionPrecomputedLayoutResult *>="_collection"@}, {Optional<BKCollectionPendingScrollEvent>="_storage"{Storage<BKCollectionPendingScrollEvent, true, true, true>="hasValue"B"value"{BKCollectionPendingScrollEvent="index"q"scrollPosition"Q"additionalScrollOffset"d"animated"B}}}, {Optional<BKCollectionStartingIndexConfig>="_storage"{Storage<BKCollectionStartingIndexConfig, true, true, true>="hasValue"B"value"{BKCollectionStartingIndexConfig="hasScrolled"B"index"q"shouldUseSnapForStartingIndex"B}}}, {Optional<long>="_storage"{Storage<long, true, true, true>="hasValue"Q"value"q}}, {queue<std::pair<NSArray<BKModel *> *, bool>, std::deque<std::pair<NSArray<BKModel *> *, bool>>>="c"{deque<std::pair<NSArray<BKModel *> *, bool>, std::allocator<std::pair<NSArray<BKModel *> *, bool>>>="__map_"{__split_buffer<std::pair<NSArray<BKModel *> *, bool> *, std::allocator<std::pair<NSArray<BKModel *> *, bool> *>>="__first_"^^v"__begin_"^^v"__end_"^^v"__end_cap_"{__compressed_pair<std::pair<NSArray<BKModel *> *, bool> **, std::allocator<std::pair<NSArray<BKModel *> *, bool> *>>="__value_"^^v}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<std::pair<NSArray<BKModel *> *, bool>>>="__value_"Q}}}, {unordered_map<unsigned long, BKLispyExpression *, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<const unsigned long, BKLispyExpression *>>>="__table_"{__hash_table<std::__hash_value_type<unsigned long, BKLispyExpression *>, std::__unordered_map_hasher<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::hash<unsigned long>, std::equal_to<unsigned long>>, std::__unordered_map_equal<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::equal_to<unsigned long>, std::hash<unsigned long>>, std::allocator<std::__hash_value_type<unsigned long, BKLispyExpression *>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::hash<unsigned long>, std::equal_to<unsigned long>>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::equal_to<unsigned long>, std::hash<unsigned long>>>="__value_"f}}};

@interface BKBloksCollectionComponentController : BKBloksComponentController<UIScrollViewDelegate, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout> {
  /* instance variables */
  NSArray *_items;
  UICollectionView *_collectionView;
  unsigned long long _direction;
  struct BKLayoutControllersManager { NSMapTable *_clientIDToLayoutController; struct recursive_mutex { struct _opaque_pthread_mutex_t { long long __sig; char x[56] __opaque; } __m_; } _mutex; } _layoutControllerManager;
  unsigned long long _snapType;
  double _leftSnapOffset;
  struct unordered_map<unsigned long, BKLispyExpression *, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<const unsigned long, BKLispyExpression *>>> { struct __hash_table<std::__hash_value_type<unsigned long, BKLispyExpression *>, std::__unordered_map_hasher<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::hash<unsigned long>, std::equal_to<unsigned long>>, std::__unordered_map_equal<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::equal_to<unsigned long>, std::hash<unsigned long>>, std::allocator<std::__hash_value_type<unsigned long, BKLispyExpression *>>> { struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>>> { struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>>> { void * *__value_; struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>> { struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>> { unsigned long long __value_; } __data_; } __value_; } __ptr_; } __bucket_list_; struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *>>> { struct __hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> { void *__next_; } __value_; } __p1_; struct __compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::hash<unsigned long>, std::equal_to<unsigned long>>> { unsigned long long __value_; } __p2_; struct __compressed_pair<float, std::__unordered_map_equal<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::equal_to<unsigned long>, std::hash<unsigned long>>> { float __value_; } __p3_; } __table_; } _appearCallbacks;
  struct unordered_map<unsigned long, BKLispyExpression *, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<const unsigned long, BKLispyExpression *>>> { struct __hash_table<std::__hash_value_type<unsigned long, BKLispyExpression *>, std::__unordered_map_hasher<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::hash<unsigned long>, std::equal_to<unsigned long>>, std::__unordered_map_equal<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::equal_to<unsigned long>, std::hash<unsigned long>>, std::allocator<std::__hash_value_type<unsigned long, BKLispyExpression *>>> { struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>>> { struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>>> { void * *__value_; struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>> { struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> *>> { unsigned long long __value_; } __data_; } __value_; } __ptr_; } __bucket_list_; struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *>>> { struct __hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long, BKLispyExpression *>, void *> *> { void *__next_; } __value_; } __p1_; struct __compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::hash<unsigned long>, std::equal_to<unsigned long>>> { unsigned long long __value_; } __p2_; struct __compressed_pair<float, std::__unordered_map_equal<unsigned long, std::__hash_value_type<unsigned long, BKLispyExpression *>, std::equal_to<unsigned long>, std::hash<unsigned long>>> { float __value_; } __p3_; } __table_; } _disappearCallbacks;
  id _collectionComponentHandler;
  BOOL _isPerformingBackgroundLayout;
  struct queue<std::pair<NSArray<BKModel *> *, bool>, std::deque<std::pair<NSArray<BKModel *> *, bool>>> { struct deque<std::pair<NSArray<BKModel *> *, bool>, std::allocator<std::pair<NSArray<BKModel *> *, bool>>> { struct __split_buffer<std::pair<NSArray<BKModel *> *, bool> *, std::allocator<std::pair<NSArray<BKModel *> *, bool> *>> { void * *__first_; void * *__begin_; void * *__end_; struct __compressed_pair<std::pair<NSArray<BKModel *> *, bool> **, std::allocator<std::pair<NSArray<BKModel *> *, bool> *>> { void * *__value_; } __end_cap_; } __map_; unsigned long long __start_; struct __compressed_pair<unsigned long, std::allocator<std::pair<NSArray<BKModel *> *, bool>>> { unsigned long long __value_; } __size_; } c; } _pendingChanges;
  BOOL _enableBackgroundLayout;
  NSArray *_processingItems;
  BOOL _isComputingSplitChangeset;
  BOOL _enableSplitChangest;
  struct Optional<BKCollectionStartingIndexConfig> { struct Storage<BKCollectionStartingIndexConfig, true, true, true> { BOOL hasValue; struct BKCollectionStartingIndexConfig { BOOL hasScrolled; long long index; BOOL shouldUseSnapForStartingIndex; } value; } _storage; } _startingIndexConfig;
  struct Optional<long> { struct Storage<long, true, true, true> { unsigned long long hasValue; long long value; } _storage; } _pendingScrollToIndex;
  struct Optional<BKCollectionPendingScrollEvent> { struct Storage<BKCollectionPendingScrollEvent, true, true, true> { BOOL hasValue; struct BKCollectionPendingScrollEvent { long long index; unsigned long long scrollPosition; double additionalScrollOffset; BOOL animated; } value; } _storage; } _pendingScrollForPendingItem;
  BOOL _shouldFlashScrollIndicator;
  NSObject<BKBloksCollectionLayoutManager> *_layoutManager;
  undefined * _itemLayoutComputer;
  undefined * _sizeConstraintsComputer;
  unsigned long long _measurementVersion;
  unsigned long long _alignItemsOnCrossAxis;
  struct CKCocoaCollectionAdapter<BKBloksCollectionPrecomputedLayoutResult *> { id _collection; } _precomputedLayoutResults;
  struct CGSize { double width; double height; } _viewSize;
  BKBloksCollectionScrollIndicatorView *_scrollIndicatorView;
  BKModel *_currentModel;
  BOOL _isDragging;
  NSIndexPath *_snapTargetIndex;
  id _onScrollSnapCallback_DEPRECATED;
  id _onScrollSnapV2Callback;
  id _scrollPerfLogger;
  BKLispyExpression *_cachedOnScrollCallback;
  BKLispyExpression *_cachedOnPageScrollCallback;
  BOOL _unmounted;
}

@property (weak, nonatomic) NSObject<BKBloksCollectionComponentControllerDelegate> *delegate;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@optional
@property (readonly, copy) NSString *debugDescription;

/* instance methods */
- (void)didMount:(id)mount;
- (void)didAcquireView:(id)view;
- (void)willUnmount:(id)unmount;
- (void)component:(id)component didPrepareLayout:(const void *)layout;
- (struct CGPoint { double x0; double x1; })contentOffset;
- (void)setContentOffset:(struct CGPoint { double x0; double x1; })offset animated:(BOOL)animated;
- (id)getAndInitHandlerIfNeeded;
- (long long)numberOfSectionsInCollectionView:(id)view;
- (long long)collectionView:(id)view numberOfItemsInSection:(long long)section;
- (double)collectionView:(id)view layout:(id)layout minimumLineSpacingForSectionAtIndex:(long long)index;
- (double)collectionView:(id)view layout:(id)layout minimumInteritemSpacingForSectionAtIndex:(long long)index;
- (struct UIEdgeInsets { double x0; double x1; double x2; double x3; })collectionView:(id)view layout:(id)layout insetForSectionAtIndex:(long long)index;
- (struct CGSize { double x0; double x1; })collectionView:(id)view layout:(id)layout sizeForItemAtIndexPath:(id)path;
- (id)collectionView:(id)view cellForItemAtIndexPath:(id)path;
- (void)collectionView:(id)view willDisplayCell:(id)cell forItemAtIndexPath:(id)path;
- (void)collectionView:(id)view didEndDisplayingCell:(id)cell forItemAtIndexPath:(id)path;
- (void)scrollViewWillEndDragging:(id)dragging withVelocity:(struct CGPoint { double x0; double x1; })velocity targetContentOffset:(inout struct CGPoint *)offset;
- (void)scrollViewDidScroll:(id)scroll;
- (void)scrollViewDidEndDragging:(id)dragging willDecelerate:(BOOL)decelerate;
- (void)scrollViewWillBeginDragging:(id)dragging;
- (void)scrollViewDidEndDecelerating:(id)decelerating;
- (void)scrollViewDidEndScrollingAnimation:(id)animation;
- (void)_invokeOnScrollSnapCallbacksWithIndex:(long long)index isUserInitiated:(BOOL)initiated;
@end

#endif /* BKBloksCollectionComponentController_h */
